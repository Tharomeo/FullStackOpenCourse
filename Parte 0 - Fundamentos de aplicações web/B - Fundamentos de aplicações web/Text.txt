--Fundamentos de aplica√ß√µes web--
Antes de come√ßarmos a programar, passaremos por alguns princ√≠pios de desenvolvimento web examinando uma aplica√ß√£o de exemplo em https://studies.cs.helsinki.fi/exampleapp.

A aplica√ß√£o serve apenas para demonstrar alguns conceitos b√°sicos do curso e, de maneira alguma, √© um exemplo de como uma aplica√ß√£o web moderna deve ser feita. Pelo contr√°rio, ela demonstra algumas t√©cnicas antigas de desenvolvimento web, que at√© poderiam ser consideradas como pr√°ticas ruins hoje em dia.

O c√≥digo seguir√° as melhores pr√°ticas contempor√¢neas a partir da parte 1 em diante.

Abra a aplica√ß√£o de exemplo em seu navegador. √Äs vezes demora um pouco.

O conte√∫do do curso √© feito utilizando o navegador Chrome.

A 1¬™ regra de desenvolvimento web: Mantenha sempre o "Console do Desenvolvedor" aberto em seu navegador web. No macOS, abra o console pressionando F12 ou option-cmd-i simultaneamente. No Windows ou Linux, abra o console pressionando F12 ou ctrl-shift-i simultaneamente. O console tamb√©m pode ser aberto via tecla Menu.

Lembre-se de sempre manter o console do desenvolvedor aberto ao desenvolver aplica√ß√µes web.

O console do desenvolvedor √© mais ou menos assim:

Captura de tela das ferramentas do desenvolvedor aberta em um browser
Certifique-se de que a guia Rede (Network) do navegador esteja aberta e marque a op√ß√£o Desativar cache (Disable cache) conforme mostrado. Preservar registro (Preserve log) tamb√©m pode ser √∫til: ele salva os logs impressos pela aplica√ß√£o quando a p√°gina √© recarregada.

Obs.: A guia mais importante √© a Console. No entanto, nesta introdu√ß√£o, usaremos mais a guia Rede (Network).



--HTTP GET--
O servidor e o navegador web se comunicam usando o protocolo HTTP. A guia Rede mostra como o navegador e o servidor se comunicam.

Quando voc√™ recarrega a p√°gina (pressione a tecla F5 ou o s√≠mbolo ‚Üª em seu navegador), o console mostrar√° que dois eventos aconteceram:

O navegador baixou o conte√∫do da p√°gina studies.cs.helsinki.fi/exampleapp do servidor; e
E baixou a imagem kuva.png.
Captura de tela do console do desenvolvedor mostrando esses dois eventos
Se estiver utilizando um monitor pequeno, ter√° que ampliar a janela do console para conseguir ver claramente.

Ao clicar no primeiro evento, mais informa√ß√µes sobre o que est√° acontecendo s√£o reveladas:

Vis√£o detalhada de um √∫nico evento
Na parte superior, Geral (General), mostra que o navegador requisitou o endere√ßo https://studies.cs.helsinki.fi/exampleapp usando o m√©todo GET (embora o endere√ßo tenha mudado ligeiramente desde que esta imagem foi feita) e que a requisi√ß√£o foi bem-sucedida, pois o servidor respondeu com o c√≥digo de status 200.

A requisi√ß√£o e a resposta do servidor possuem v√°rios cabe√ßalhos (headers):

Captura de tela dos cabe√ßalhos de resposta
Os cabe√ßalhos de resposta no topo nos dizem, por exemplo, o tamanho da resposta em bytes e o momento exato da resposta. Um cabe√ßalho importante, Content-Type, nos diz que a resposta √© um arquivo de texto no formato utf-8 e que os conte√∫dos foram formatados em HTML. Dessa forma, o navegador sabe que a resposta √© uma p√°gina HTML comum e a renderiza para o navegador "como uma p√°gina web".

A guia Resposta (Response) mostra os dados de resposta, uma p√°gina HTML comum. A se√ß√£o body determina a estrutura da p√°gina renderizada na tela:

Captura de tela da guia Resposta
A p√°gina cont√©m um elemento div, que por sua vez cont√©m um t√≠tulo, um link para a p√°gina notes e uma tag img, e exibe o n√∫mero de notas criadas.

Devido √† tag "img", o navegador faz uma segunda requisi√ß√£o HTTP para buscar a imagem kuva.png do servidor. Os detalhes da requisi√ß√£o s√£o os seguintes:

Imagem detalhada do segundo evento
A requisi√ß√£o foi feita para o endere√ßo https://studies.cs.helsinki.fi/exampleapp/kuva.png e o seu tipo √© HTTP GET. Os cabe√ßalhos de resposta (response headers) nos dizem que o tamanho da resposta √© 89350 bytes e seu Content-type √© image/png, ent√£o √© uma imagem png. O navegador usa essa informa√ß√£o para renderizar a imagem corretamente na tela.

O encadeamento de eventos causado pela abertura da p√°gina https://studies.cs.helsinki.fi/exampleapp no navegador forma o seguinte diagrama de sequ√™ncia:

Diagrama de sequ√™ncia do fluxo descrito acima
O diagrama de sequ√™ncia demonstra como o navegador e o servidor est√£o se comunicando ao longo do tempo. O tempo flui no diagrama de cima para baixo, ent√£o se inicia com a primeira requisi√ß√£o que o navegador envia ao servidor, seguido pela resposta.

Primeiro, o navegador envia uma requisi√ß√£o HTTP GET ao servidor para buscar o c√≥digo HTML da p√°gina. A tag img no HTML requisita que o navegador busque a imagem kuva.png. O navegador renderiza a p√°gina HTML e a imagem na tela.

Embora seja dif√≠cil notar, a p√°gina HTML come√ßa a ser renderizada antes que a imagem tenha sido buscada do servidor.



--Aplica√ß√µes web tradicionais--
A p√°gina inicial da aplica√ß√£o de exemplo funciona como uma aplica√ß√£o web tradicional. Ao entrar na p√°gina, o navegador busca o documento HTML que detalha a estrutura e o conte√∫do textual da p√°gina no servidor.

O servidor formou esse documento de alguma forma. O documento pode ser um arquivo de texto est√°tico salvo no diret√≥rio do servidor. O servidor tamb√©m pode formar os documentos HTML dinamicamente de acordo com o c√≥digo da aplica√ß√£o, utilizando, por exemplo, dados de um banco de dados. O c√≥digo HTML da aplica√ß√£o de exemplo foi formado dinamicamente porque cont√©m informa√ß√µes sobre o n√∫mero de notas criadas.

O c√≥digo HTML da p√°gina inicial √© o seguinte:

const getFrontPageHtml = noteCount => {
  return `
    <!DOCTYPE html>
    <html>
      <head>
      </head>
      <body>
        <div class='container'>
          <h1>Exemplo de aplica√ß√£o Full Stack</h1>
          <p>N√∫mero de notas criadas: ${noteCount}</p>
          <a href='/notes'>notes</a>
          <img src='kuva.png' width='200' />
        </div>
      </body>
    </html>
`
}

app.get('/', (req, res) => {
  const page = getFrontPageHtml(notes.length)
  res.send(page)
})copy
Voc√™ n√£o precisa entender o c√≥digo agora.

O conte√∫do da p√°gina HTML foi salvo como uma string-modelo ou uma string que permite avaliar, por exemplo, vari√°veis dentro dela. A parte da p√°gina inicial que muda dinamicamente, o n√∫mero de notas salvas (no c√≥digo noteCount), √© substitu√≠da pelo n√∫mero atual de notas (no c√≥digo notes.length) na string de modelo.

Escrever HTML no meio do c√≥digo n√£o √© algo interessante de se fazer, mas para os programadores PHP antigos, isso era uma pr√°tica normal.

Em aplica√ß√µes web tradicionais, o navegador √© "burro". Ele s√≥ busca dados HTML do servidor e toda a l√≥gica da aplica√ß√£o est√° no servidor. Um servidor pode ser criado usando Java Spring, Python Flask ou Ruby on Rails, para citar apenas alguns exemplos.

O exemplo usa a biblioteca Express com Node.js. Este curso usar√° Node.js e Express para criar servidores web.



--Executando a l√≥gica da aplica√ß√£o no navegador--
Mantenha o Console do Desenvolvedor aberto. Esvazie o console clicando no s√≠mbolo üö´ ou digitando clear() no console. Agora, quando voc√™ for para a p√°gina notes, o navegador far√° 4 (quatro) requisi√ß√µes HTTP:

Captura de tela do console do desenvolvedor com 4 requisi√ß√µes vis√≠veis
Todas as requisi√ß√µes t√™m tipos diferentes. O tipo da primeira requisi√ß√£o √© document. √â o c√≥digo HTML da p√°gina, e ele √© assim:

Imagem detalhada da primeira requisi√ß√£o
Quando comparamos a p√°gina mostrada no navegador e o c√≥digo HTML retornado pelo servidor, notamos que o c√≥digo n√£o cont√©m a lista de notas. A se√ß√£o head do HTML cont√©m uma tag script, que faz com que o navegador busque um arquivo JavaScript chamado main.js.

O c√≥digo JavaScript fica assim:

var xhttp = new XMLHttpRequest()

xhttp.onreadystatechange = function() {
  if (this.readyState == 4 && this.status == 200) {
    const data = JSON.parse(this.responseText)
    console.log(data)

    var ul = document.createElement('ul')
    ul.setAttribute('class', 'notes')

    data.forEach(function(note) {
      var li = document.createElement('li')

      ul.appendChild(li)
      li.appendChild(document.createTextNode(note.content))
    })

    document.getElementsByClassName('notes').appendChild(ul)
  }
}

xhttp.open('GET', '/data.json', true)
xhttp.send()copy
Os detalhes do c√≥digo n√£o s√£o importantes agora, mas algum c√≥digo foi inclu√≠do para dar vida √†s imagens e ao texto. Come√ßaremos a programar de verdade na parte 1. O c√≥digo-exemplo nesta parte, na realidade, n√£o tem rela√ß√£o alguma com as t√©cnicas de programa√ß√£o deste curso.

Alguns podem se perguntar o porqu√™ do objeto "xhttp" ser usado aqui em vez do moderno "fetch" ("buscar" ou "ir buscar"). Isso se deve ao fato de n√£o querermos entrar no assunto das "Promises" (promessas) ainda, e o c√≥digo ter um papel secund√°rio nesta parte. Voltaremos √†s formas modernas de fazer requisi√ß√µes ao servidor na Parte 2.

Imediatamente ap√≥s baixar a tag script, o navegador come√ßa a executar o c√≥digo.

As √∫ltimas duas linhas instruem o navegador a fazer uma requisi√ß√£o HTTP GET ao endere√ßo do servidor /data.json:

xhttp.open('GET', '/data.json', true)
xhttp.send()copy
Esta √© a requisi√ß√£o mais "profunda" exibida na guia de Rede.

Podemos tentar ir ao endere√ßo https://studies.cs.helsinki.fi/exampleapp/data.json diretamente do navegador:

Dados JSON brutos
L√° encontramos as notas em formato de "dados brutos" JSON. Por padr√£o, os navegadores baseados em Chromium n√£o s√£o muito bons em exibir dados JSON. √â poss√≠vel usar plugins para lidar com a formata√ß√£o. Instale, por exemplo, a extens√£o JSONVue no Chrome e recarregue a p√°gina. Os dados agora est√£o formatados corretamente:

Sa√≠da JSON formatada
Ent√£o, o c√≥digo JavaScript da p√°gina de notas ilustrada acima baixa os dados JSON contendo as notas e forma uma lista de itens de notas a partir do seu conte√∫do:

Isso √© feito pelo seguinte c√≥digo:

const data = JSON.parse(this.responseText)
console.log(data)

var ul = document.createElement('ul')
ul.setAttribute('class', 'notes')

data.forEach(function(note) {
  var li = document.createElement('li')

  ul.appendChild(li)
  li.appendChild(document.createTextNode(note.content))
})

document.getElementById('notes').appendChild(ul)copy
O c√≥digo cria primeiro uma lista n√£o ordenada com a tag ul...

var ul = document.createElement('ul')
ul.setAttribute('class', 'notes')copy
...e em seguida, adiciona uma tag li para cada nota. Somente o campo content de cada nota se torna o conte√∫do da tag li. Os "timestamps" (registros de data/hora) encontrados nos dados JSON n√£o s√£o utilizados para nada neste caso.

data.forEach(function(note) {
  var li = document.createElement('li')

  ul.appendChild(li)
  li.appendChild(document.createTextNode(note.content))
})copy
Abra a guia Console no seu Console do Desenvolvedor:

Captura de tela da guia console no Console do Desenvolvedor
Ao clicar no pequeno tri√¢ngulo no in√≠cio da linha, voc√™ expande o texto na guia Console.

Captura de tela de uma das entradas anteriormente colapsadas expandida
Esse "output" (sa√≠da) no console √© fruto do comando console.log no c√≥digo:

const data = JSON.parse(this.responseText)
console.log(data)copy
Ent√£o, ap√≥s receber os dados do servidor, o c√≥digo os imprime no console.

Voc√™ se familiarizar√° com a guia Console e o comando console.log no decorrer do curso.



--Gerenciadores de Evento (Event handlers) e Fun√ß√µes Callback--
A estrutura desse c√≥digo √© um pouco estranha:

var xhttp = new XMLHttpRequest()

xhttp.onreadystatechange = function() {
  // c√≥digo que lida com a resposta do servidor
}

xhttp.open('GET', '/data.json', true)
xhttp.send()copy
A requisi√ß√£o ao servidor √© feita na √∫ltima linha, mas o c√≥digo que lida com a resposta √© encontrado mais acima. O que est√° acontecendo?

xhttp.onreadystatechange = function () {copy
Nessa linha, um event handler ("gerenciador de evento" ou "manipulador de evento") para o evento onreadystatechange √© definido para o objeto xhttp que faz a requisi√ß√£o. Quando o estado do objeto muda, o navegador chama a fun√ß√£o gerenciadora de evento. O c√≥digo da fun√ß√£o verifica que o readyState √© igual a 4 (o que representa o estado "DONE" que exibe a descri√ß√£o A opera√ß√£o est√° completa) e que o c√≥digo de status HTTP da resposta √© 200.

xhttp.onreadystatechange = function() {
  if (this.readyState == 4 && this.status == 200) {
    // c√≥digo que gerencia a resposta do servidor
  }
}copy
O mecanismo de chamada de gerenciadores de eventos √© muito comum em JavaScript. As fun√ß√µes de ger√™ncia de eventos s√£o chamadas de fun√ß√µes callback (fun√ß√µes de retorno de chamada). O c√≥digo da aplica√ß√£o n√£o chama as fun√ß√µes em si, mas o "runtime environment" (ambiente de tempo de execu√ß√£o) ‚Äî isto √©, o navegador, que chama a fun√ß√£o no tempo correto quando o evento acontece.




--Modelo de Documento por Objetos (DOM [Document Object Model])--
Podemos pensar em p√°ginas HTML como estruturas impl√≠citas de uma √°rvore.

html
  head
    link
    script
  body
    div
      h1
      div
        ul
          li
          li
          li
      form
        input
        input
copy
A mesma estrutura de √°rvore pode ser vista na guia Elementos do console.

Captura de tela da guia Elementos do Console do Desenvolvedor
O funcionamento do navegador baseia-se na ideia de representar os elementos HTML como uma √°rvore.

O Modelo de Documento por Objetos, ou DOM, √© uma API (Application Programming Interface), isto √© uma Interface de Programa√ß√£o de Aplica√ß√£o, que possibilita a modifica√ß√£o program√°tica das √°rvores de elementos correspondentes √†s p√°ginas web.

O c√≥digo JavaScript introduzido no cap√≠tulo anterior usou a API DOM para adicionar uma lista de notas na p√°gina.

O c√≥digo a seguir cria um novo n√≥ (node) na vari√°vel ul e adiciona alguns n√≥s-filho a ele:

var ul = document.createElement('ul')

data.forEach(function(note) {
  var li = document.createElement('li')

  ul.appendChild(li)
  li.appendChild(document.createTextNode(note.content))
})copy
Por fim, a ramifica√ß√£o da √°rvore da vari√°vel ul √© conectada ao seu lugar previsto na √°rvore HTML da p√°gina:

document.getElementsByClassName('notes').appendChild(ul)copy



--Gerenciando o objeto "Document" por meio do console--
O n√≥ de n√≠vel mais alto da √°rvore DOM de um documento HTML √© o objeto document. Podemos realizar v√°rias opera√ß√µes em uma p√°gina web usando a API DOM. Voc√™ consegue acessar o objeto document digitando document na guia Console:

Documento na guia do console das Ferramentas do Desenvolvedor
Vamos adicionar uma nova nota √† p√°gina a partir do console.

Primeiro, vamos pegar a lista de notas da p√°gina. A lista est√° no primeiro elemento "ul" da p√°gina:

list = document.getElementsByTagName('ul')[0]copy
Em seguida, criamos um novo elemento "li" e adicionamos algum conte√∫do de texto a ele:

newElement = document.createElement('li')
newElement.textContent = 'Page manipulation from console is easy'copy
E adicionamos o novo elemento "li" √† lista:

list.appendChild(newElement)copy
Captura de tela da p√°gina com a nova nota adicionada √† lista
Mesmo que a p√°gina seja atualizada no seu navegador, as mudan√ßas n√£o s√£o permanentes. Se a p√°gina for recarregada, a nova nota desaparecer√°, pois as mudan√ßas n√£o foram enviadas ao servidor. O c√≥digo JavaScript que o navegador busca sempre criar√° a lista de notas com base nos dados JSON do endere√ßo https://studies.cs.helsinki.fi/exampleapp/data.json.




--CSS--
O elemento head (cabe√ßalho) do c√≥digo HTML da p√°gina Notes cont√©m uma tag link, que determina que o navegador deve buscar uma folha de estilo CSS a partir do endere√ßo main.css.

CSS (Cascading Style Sheets - folhas de estilo em cascata), √© uma linguagem de estilo usada para determinar a apar√™ncia de p√°ginas web.

O arquivo CSS baixado √© o seguinte:

.container {
  padding: 10px;
  border: 1px solid;
}

.notes {
  color: blue;
}copy
O arquivo define dois seletores de classe. Eles s√£o utilizados para selecionar certas partes da p√°gina e para definir regras de estilo para estiliz√°-las.

Uma defini√ß√£o de seletor de classe sempre come√ßa com um ponto e cont√©m o nome da classe.

As classes s√£o atributos, que podem ser adicionados √† elementos HTML.

Atributos CSS podem ser examinados na guia Elementos (Elements):

Captura de tela da guia Elementos
O elemento div mais externo tem a classe container. O elemento ul que cont√©m a lista de notas tem a classe notes.

A primeira regra CSS define que elementos com a classe container ter√£o a borda da largura de um pixel. Ele tamb√©m define um padding de 10 pixels no elemento. Essa propriedade adiciona um espa√ßo vazio entre o conte√∫do do elemento e a borda.

A segunda regra CSS define a cor do texto das notas como azul.

Os elementos HTML tamb√©m podem ter outros atributos al√©m de classes. O elemento div, que cont√©m as notas, tem um atributo id (identificador[exclusivo]). O c√≥digo JavaScript usa o "id" para encontrar o elemento.

A guia Elementos (Elements) do console pode ser usada para alterar os estilos dos elementos.

Guia Elementos das Ferramentas do Desenvolvedor
As altera√ß√µes feitas no console n√£o ser√£o permanentes. Se deseja fazer altera√ß√µes duradouras, elas devem ser salvas na folha de estilo CSS no servidor.



--Carregando uma p√°gina contendo JavaScript ‚Äî revis√£o--
Vamos revisar o que acontece quando a p√°gina https://studies.cs.helsinki.fi/exampleapp/notes √© aberta no navegador.

Diagrama de sequ√™ncia da intera√ß√£o navegador/servidor
O navegador busca o c√≥digo HTML que define o conte√∫do e a estrutura da p√°gina do servidor usando uma requisi√ß√£o HTTP GET;
Os links no c√≥digo HTML fazem com que o navegador tamb√©m busque a folha de estilo CSS main.css...
...e um arquivo de c√≥digo JavaScript main.js;
O navegador executa o c√≥digo JavaScript. O c√≥digo faz uma requisi√ß√£o HTTP GET para o endere√ßo https://studies.cs.helsinki.fi/exampleapp/data.json, que retorna as notas como dados JSON; e
Quando √© finalizada a busca pelos dados, o navegador executa um event handler, que renderiza as notas na p√°gina usando a API DOM.




--Formul√°rios (Forms) e HTTP POST--
Agora, vamos examinar como se adiciona uma nova nota.

A p√°gina de notas cont√©m um elemento formul√°rio (form).

Elemento de formul√°rio destacado tanto na p√°gina web quanto nas Ferramentas do Desenvolvedor
Quando o bot√£o no formul√°rio √© clicado, o navegador envia a entrada (input) do usu√°rio para o servidor. Vamos abrir a guia Rede (Network) e ver como se envia o formul√°rio:

Captura de tela da guia de Rede onde os eventos para enviar o formul√°rio s√£o mostrados
Surpreendentemente, o envio do formul√°rio gera n√£o menos que cinco requisi√ß√µes HTTP. A primeira √© o evento de envio do formul√°rio. Vamos focar nessa parte:

Visualiza√ß√£o detalhada da primeira requisi√ß√£o
Trata-se de uma requisi√ß√£o HTTP POST para o endere√ßo do servidor newnote. O servidor responde com o c√≥digo de status HTTP 302. Isso √© um [redirecionamento de URL](https://en.wikipedia.org/wiki/URLredirection), no qual o servidor pede ao navegador para fazer uma nova requisi√ß√£o HTTP GET para o endere√ßo definido no cabe√ßalho Localiza√ß√£o (Location) ‚Äî o endere√ßo notes.

Ent√£o, o navegador recarrega a p√°gina de Notas (Notes). O recarregamento faz mais tr√™s requisi√ß√µes HTTP: busca o arquivo CSS (main.css), o arquivo de JavaScript (main.js) e os dados das notas (data.json).

A guia de Rede tamb√©m mostra os dados enviados com o formul√°rio:

Obs.: Na vers√£o mais recente do Chrome, o menu drop-down (lista suspensa) "Form Data" est√° dentro da nova guia "Payload", localizada √† direita da guia "Cabe√ßalhos".

Menu drop-down do Form Data das Ferramentas do Desenvolvedor
A tag Form tem os atributos action e method, que definem que o envio do formul√°rio √© feito como uma requisi√ß√£o HTTP POST para o endere√ßo new_note.

Destaque dos atributos action e method
O c√≥digo no servidor respons√°vel pela requisi√ß√£o POST √© bastante simples (Obs.: este c√≥digo est√° no servidor, e n√£o no c√≥digo JavaScript baixado pelo navegador):

app.post('/new_note', (req, res) => {
  notes.push({
    content: req.body.note,
    date: new Date(),
  })

  return res.redirect('/notes')
})copy
Os dados s√£o enviados como o body da requisi√ß√£o POST.

O servidor consegue acessar os dados acessando o campo req.body do objeto de requisi√ß√£o req.

O servidor cria um novo objeto nota e adiciona-o a um array chamado notes.

notes.push({
  content: req.body.note,
  date: new Date(),
})copy
Os objetos de "Notes" t√™m dois campos: content, contendo o conte√∫do real da nota; e date, contendo a data e hora em que a nota foi criada.

O servidor n√£o salva as novas notas em um banco de dados, ent√£o elas desaparecem quando o servidor √© reiniciado.



--AJAX--
A p√°gina "Notes", da nossa aplica√ß√£o, segue um estilo de desenvolvimento web dos anos 90 e usa "Ajax". Como tal, ela est√° na crista da onda da tecnologia web dos anos 2000.

AJAX (Asynchronous JavaScript and XML, ou seja, JavaScript Ass√≠ncrono e XML) √© um termo que foi introduzido em fevereiro de 2005 com base em avan√ßos na tecnologia do navegador para descrever uma nova abordagem revolucion√°ria que permitia o carregamento de conte√∫do em p√°ginas web usando JavaScript embutido dentro do HTML, sem a necessidade de re-renderizar a p√°gina.

Antes da Era AJAX, todas as p√°ginas web funcionavam como a aplica√ß√£o web tradicional que vimos anteriormente neste cap√≠tulo. Todos os dados mostrados na p√°gina eram buscados com o c√≥digo HTML gerado pelo servidor.

A p√°gina "Notes" usa AJAX para buscar os dados das notas. O envio do formul√°rio ainda usa o mecanismo tradicional de envio de formul√°rios web.

As URLs da aplica√ß√£o refletem os tempos antigos e despreocupados. Os dados JSON s√£o buscados na URL https://studies.cs.helsinki.fi/exampleapp/data.json e novas notas s√£o enviadas para a URL https://studies.cs.helsinki.fi/exampleapp/new_note. Hoje em dia, URLs como essas n√£o seriam consideradas aceit√°veis, pois n√£o seguem as conven√ß√µes geralmente reconhecidas de APIs RESTful (Representational State Transfer (REST) [Transfer√™ncia de Estado Representacional]), que veremos com mais detalhes na parte 3.

O conceito por detr√°s do termo AJAX agora √© t√£o cotidiano e b√°sico que n√£o se verifica nele nenhuma novidade para os dias atuais. O termo caiu no esquecimento e a nova gera√ß√£o nem sequer ouviu falar dele.



--Single Page Application (SPA)--
Em nossa aplica√ß√£o de exemplo, a p√°gina inicial funciona como uma p√°gina web tradicional: toda a l√≥gica est√° no servidor e o navegador s√≥ renderiza o HTML conforme instru√≠do.

A p√°gina "Notes" transfere algumas dessas responsabilidades para o navegador, gerando o c√≥digo HTML para notas que j√° existem. O navegador realiza essa tarefa executando o c√≥digo JavaScript que ele baixou do servidor. O c√≥digo baixa as notas do servidor como dados JSON e adiciona elementos HTML para exibir as notas na p√°gina usando a API DOM.

Nos √∫ltimos anos, o estilo SPA (Single Page Aplication) de cria√ß√£o de aplica√ß√µes web surgiu. Os sites de estilo SPA n√£o baixam todas as suas p√°ginas separadamente do servidor como o nosso exemplo de aplica√ß√£o faz, mas incluem apenas uma p√°gina HTML baixada do servidor, cujo conte√∫do √© manipulado com o c√≥digo JavaScript que √© executado no navegador.

A p√°gina "Notes" da nossa aplica√ß√£o tem alguma semelhan√ßa com as aplica√ß√µes de estilo SPA, mas ainda n√£o est√° bem l√°. Mesmo que a l√≥gica para renderizar as notas seja executada no navegador, a p√°gina ainda usa o mecanismo tradicional de adi√ß√£o de novas notas. Os dados s√£o enviados para o servidor atrav√©s do envio do formul√°rio e o servidor instrui o navegador a recarregar a p√°gina "Notes" com um redirect.

Uma vers√£o SPA da aplica√ß√£o que estamos utilizando de exemplo pode ser encontrada em https://studies.cs.helsinki.fi/exampleapp/spa. √Ä primeira vista, a aplica√ß√£o parece igual √† anterior. O c√≥digo HTML √© quase id√™ntico, mas o arquivo JavaScript √© diferente (spa.js), e h√° uma pequena mudan√ßa na maneira como a tag "form" √© definida:

Formul√°rio sem os atributos action e method
O formul√°rio n√£o possui atributos action ou method para definir como e onde enviar os dados de entrada.

Abra a guia Rede (Network) e esvazie-a. Quando voc√™ criar uma nova nota, ver√° que o navegador envia apenas uma requisi√ß√£o para o servidor.

Guia Rede nas Ferramentas do Desenvolvedor
A requisi√ß√£o POST para o endere√ßo new_note_spa cont√©m a nova nota como dados JSON, contendo tanto o conte√∫do da nota (content) quanto o timestamp (date):

{
  content: "Uma aplica√ß√£o de p√°gina √∫nica (SPA) n√£o recarrega toda a p√°gina",
  date: "2019-05-25T15:15:59.905Z"
}copy
O cabe√ßalho Content-Type da requisi√ß√£o informa ao servidor que os dados inclu√≠dos est√£o representados no formato JSON.

Cabe√ßalho Content-type nas Ferramentas do Desenvolvedor
Sem esse cabe√ßalho, o servidor n√£o saberia como analisar corretamente os dados.

O servidor responde com o c√≥digo de status 201. Dessa vez, o servidor n√£o requisita um redirecionamento, o navegador fica na mesma p√°gina e n√£o envia mais requisi√ß√µes HTTP.

A vers√£o SPA da nossa aplica√ß√£o n√£o envia de forma tradicional os dados do formul√°rio, mas usa o c√≥digo JavaScript que recuperou do servidor. Vamos analisar um pouco esse c√≥digo, embora entender todos os detalhes dele n√£o seja importante ainda nesta etapa.

var form = document.getElementById('notes_form')
form.onsubmit = function(e) {
  e.preventDefault()

  var note = {
    content: e.target.elements[0].value,
    date: new Date(),
  }

  notes.push(note)
  e.target.elements[0].value = ''
  redrawNotes()
  sendToServer(note)
}copy
O comando document.getElementById('notes_form') instrui o c√≥digo a buscar o elemento de formul√°rio da p√°gina e a registrar um gerenciador de evento para lidar com o evento de envio do formul√°rio. O gerenciador de evento chama imediatamente o m√©todo e.preventDefault() para evitar o tratamento padr√£o do envio do formul√°rio. O m√©todo padr√£o enviaria os dados para o servidor e causaria uma nova requisi√ß√£o GET, o que n√£o queremos que aconte√ßa.

Em seguida, o gerenciador de evento cria uma nova nota, adiciona-a √† lista de notas com o comando notes.push(note), redesenha a lista de notas na p√°gina e envia a nova nota ao servidor.

O c√≥digo para enviar a nota ao servidor √© o seguinte:

var sendToServer = function(note) {
  var xhttpForPost = new XMLHttpRequest()
  // ...

  xhttpForPost.open('POST', '/new_note_spa', true)
  xhttpForPost.setRequestHeader('Content-type', 'application/json')
  xhttpForPost.send(JSON.stringify(note))
}copy
O c√≥digo determina que os dados devem ser enviados com uma requisi√ß√£o HTTP POST e o tipo de dados deve ser JSON. O tipo de dados √© determinado com um cabe√ßalho Content-type. Em seguida, os dados s√£o enviados como uma string JSON.

O c√≥digo da aplica√ß√£o est√° dispon√≠vel em https://github.com/mluukkai/example_app. Vale ressaltar que a aplica√ß√£o serve apenas para demonstrar os conceitos do curso. O c√≥digo segue um estilo ruim de desenvolvimento em algumas partes e n√£o deve ser usado como exemplo ao criar suas pr√≥prias aplica√ß√µes. O mesmo se aplica √†s URLs usadas. A URL new_note_spa para a qual as novas notas s√£o enviadas, n√£o segue as melhores pr√°ticas usadas atualmente.




--Bibliotecas JavaScript--
A aplica√ß√£o de exemplo √© feita com o chamado JavaScript "vanilla" (ou JavaScript "puro"), usando somente a API DOM e JavaScript para manipular a estrutura das p√°ginas.

Em vez de usar somente JavaScript e a API DOM, √© comum usar diferentes bibliotecas que cont√™m ferramentas mais f√°ceis de trabalhar em compara√ß√£o com a API DOM para manipular p√°ginas. Uma dessas bibliotecas √© a popular jQuery.

A biblioteca jQuery foi desenvolvida quando as aplica√ß√µes web seguiam principalmente o estilo tradicional do servidor gerando p√°ginas HTML, cuja funcionalidade era aprimorada no lado do navegador usando JavaScript escrito com jQuery. Uma das raz√µes para o sucesso de jQuery foi a sua compatibilidade cross-browser (compatibilidade entre navegadores). A biblioteca funcionava independentemente do navegador ou da empresa que a fez, ent√£o n√£o havia necessidade de solu√ß√µes espec√≠ficas para cada navegador. Hoje em dia, usar jQuery n√£o √© t√£o justific√°vel dada a evolu√ß√£o do JavaScript e dos navegadores mais populares, que de modo geral d√£o um bom suporte √†s funcionalidades b√°sicas.

A ascens√£o das SPA trouxe v√°rias formas mais "modernas" de desenvolvimento web do que jQuery. A favorita da primeira onda de desenvolvedores foi BackboneJS. Ap√≥s o seu lan√ßamento em 2012, AngularJS rapidamente se tornou quase o padr√£o de desenvolvimento web moderno da Google.

No entanto, a popularidade do Angular caiu em outubro de 2014 ap√≥s a equipe do Angular anunciar que o suporte √† vers√£o 1 encerraria-se, e o Angular 2 n√£o seria compat√≠vel com a primeira vers√£o. Angular 2 e as vers√µes mais recentes n√£o foram muito bem recebidas.

Atualmente, a ferramenta mais popular para implementar a l√≥gica do lado do cliente (navegador) de aplica√ß√µes web √© a biblioteca React do Facebook. Durante este curso, vamos nos familiarizar com o React e com a biblioteca Redux, que s√£o frequentemente usadas juntas.

O status do React parece forte, mas o mundo de JavaScript est√° sempre mudando. Por exemplo, recentemente, um novato ‚Äî VueJS ‚Äî tem chamado a aten√ß√£o.




--Desenvolvimento Web Ful Stack--
O que significa o nome do curso, Desenvolvimento Web Full Stack? A palavra "Full Stack" √© um jarg√£o de que todo mundo fala, mas ningu√©m sabe o que significa. Ou pelo menos, n√£o h√° uma defini√ß√£o padr√£o para o termo.

Praticamente, todas as aplica√ß√µes web t√™m, pelo menos, duas "camadas" (layers): o navegador, sendo mais pr√≥ximo do usu√°rio final (cliente), √© a camada superior; enquanto que o servidor √© a camada inferior. H√° tamb√©m, no geral, uma camada de banco de dados abaixo da do servidor. Podemos, portanto, pensar na arquitetura de uma aplica√ß√£o web como uma esp√©cie de pilha (stack) de camadas.

No geral, tamb√©m falamos sobre o front-end e o back-end. O navegador √© o front-end, e o JavaScript que roda no navegador √© o c√≥digo front-end. O servidor, por outro lado, √© o back-end.

No contexto deste curso, desenvolvimento web full stack significa que nos concentramos em todas as partes da aplica√ß√£o: front-end, back-end e banco de dados. √Äs vezes, o software no servidor e o sistema operacional dele s√£o vistos como partes da pilha, mas n√£o entraremos nesses detalhes.

Programaremos o back-end em JavaScript, usando o ambiente de execu√ß√£o Node.js. Usar a mesma linguagem de programa√ß√£o em m√∫ltiplas camadas da pilha d√° ao desenvolvimento web Full Stack uma nova dimens√£o. No entanto, n√£o √© uma exig√™ncia do desenvolvimento web Full Stack usar a mesma linguagem de programa√ß√£o (JavaScript) para todas as camadas da pilha.

Era mais comum que os desenvolvedores se especializassem em uma dessas camadas, por exemplo, no back-end. As tecnologias no back-end e no front-end eram bastante diferentes. Com a tend√™ncia Full Stack, tornou-se comum que os desenvolvedores tenham a habilidade de programar em todas as camadas da aplica√ß√£o e no banco de dados. Muitas vezes, os desenvolvedores full stack tamb√©m precisam ter habilidades suficientes de configura√ß√£o e administra√ß√£o para operar suas aplica√ß√µes, como na nuvem, por exemplo.




--Fadiga JavaScript--
O desenvolvimento de aplica√ß√µes web Full Stack √© de muitas maneiras desafiador. V√°rias coisas est√£o acontecendo em v√°rios lugares ao mesmo tempo, e a depura√ß√£o (debug) √© um pouco mais dif√≠cil se comparada com a depura√ß√£o de softwares de desktop comuns. JavaScript nem sempre funciona da maneira que voc√™ espera que funcione (em compara√ß√£o com muitas outras linguagens), e a forma ass√≠ncrona que seus ambientes de tempo de execu√ß√£o (runtime environments) funcionam cria todos os tipos de desafios. Comunica√ß√£o na web exige conhecimento do protocolo HTTP. Tamb√©m √© preciso lidar com bancos de dados e administra√ß√£o e configura√ß√£o de servidores. Tamb√©m seria bom saber o suficiente de CSS para tornar as aplica√ß√µes pelo menos apresent√°veis.

O mundo JavaScript se desenvolve r√°pido, o que traz seus pr√≥prios desafios. Ferramentas, bibliotecas e a pr√≥pria linguagem est√£o em constante desenvolvimento. Algumas pessoas come√ßam a ficar cansadas das constantes mudan√ßas e deram um nome para isso: fadiga JavaScript. Veja Como gerenciar a fadiga JavaScript no auth0 ou Fadiga JavaScript no site Medium.

Voc√™ sofrer√° de fadiga JavaScript durante este curso. Felizmente para n√≥s, existem algumas maneiras de suavizar a curva de aprendizado para que possamos come√ßar com programa√ß√£o em vez de configura√ß√£o. N√£o podemos evitar completamente a configura√ß√£o, mas podemos avan√ßar animadamente nas pr√≥ximas semanas evitando as piores dores de cabe√ßa da configura√ß√£o.